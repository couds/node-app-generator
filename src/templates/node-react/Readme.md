### Node+React Template project

*NOTE*: This is a Work in progress.

This is a proposal for a React template project with:

- [ReactJS](https://reactjs.org/) (with SSR for BOT's)
- [Styled Components](https://styled-components.com/) for styling
- [Redux](https://redux.js.org/) for state management
- [Redux-Observable](https://redux-observable.js.org/) for advanced state management
- [@LinguiJS](https://lingui.js.org/) for internationalization 

## How to Start

First you need to install all dependencies `npm i` or `yarn` will do the trick!

Once the template is instaled you need to run `npm run watch` to start watching your changes to transpile, after the first build its finish you can run `npm run nodemon` to start the server.

Now you can navegate to [http://localhost:3000](http://localhost:3000)

By default this will liten to `port 3000` you can change this with a env variable PORT with the new port you want to use, `PORT=3001 npm run nodemon` will start the server on port 3001.

## Deploy

Out of the box there are 2 ways to deploy an application using this template:

1. Use the docker image generated by this package, `npm run build-image` 

    This will create a docker image with tha name equal to the project name. you can add a env variable `DOCKER_REGISTRY` if you are using a private docker repository to set the prefix of the docker image tag name. Ex, If your project name is **my-awesome-project**  and you excecute `DOCKER_REGISTRY=quay.io/ npm run build-image` will create a docker image named `quay.io/my-awesome-project`.

    **Note**: If you use external dependencies that webpack did not bundle you need to update the Dockerfile to install on the last stage image

1. Deploy the transpiled version `NODE_ENV=production npm run build`

    This will create a file `dist/index.js` that will contain all your application, you can just copy this `index.js` and run it anywhere.

    **Note**: If your build and production environemt use different versions of node, change the target value in `webpack.config.json` to the version of your production environment 

## Guidelines

- File names are kebab-case
- Variable names are camelCase
- Modules should be a folder with an `index.js` that expose the module and an `[module-name].js` that contain all the login. (you can also have folders inside following the same rule). This is no a Hard rule and can be broken depending of the case (like in `services/middlewares/my-custom-middleware.js`, this file is not likely to grow so I left it as a file)
- In this structure you will notice a lot of `index.js` files, the idea is to **always** import the folder instead of a file like

  ```
  import Database from 'services/database'
  ```

  This way its easier when the project grows. let's say we create a `service/database.js` file instead of the folder, if/when the content of this file grows and need to be separated on several files you could end with something like 


  ```
  service
    -- database.js
    -- database-mongo.js
    -- database-mysql.js
    -- ...other-services...
  ```

## API Routes

The structure was made thinking of versioning the api using the url, and this will be reflected on the folder structure,

```
src/
  -- enpoints/
    -- v1
    -- v2
    ...
```

`/v[X]/my-endpoint` and also have a `/latest/my-endpoint` that should point to the latest version of your API (You can disable this in `src/endpoints/index.js`) 

## Structure

As usual your entry point is `src/index.js`

```
src
  -- enpoints
    -- v1
    -- v2
    ...
  -- services
    -- middlewares (For your express middlewares if any)
    -- database (Here you export your database connection)
    -- repositories (Here you expose your repositories/model that will be used on your routes, replace the current folders for your logic)
    -- dummy (DELETE)
```

## Troubleshooting

### Webpack fail to pack

- If you are using a library that webpack can't pack, add it as an external dependency and install it in the final docker image